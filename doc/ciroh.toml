[params]

timestep_length = 0.01          # Seconds per time step
timesteps = 1000000             # Number of time steps to run the simulation for
seed = 42                       # Random seed to use
root = "~/testnet/simulations"  # Root directory to store simulation results 
                                # into (will create a new subdirectory each run)

# Section describing different link configurations. Links are added under this
# section by adding a header such as [links.<name>]. Reserved link names are:
#   - "self": Refers to the link name for the definition it is used within.
#   - "direct": Link name reserved for direct outbound links between nodes.
#   - "indirect": Link name reserved for links without explicit connections.
#   - "ideal": Only default link name which cannot be overridden.
[links]

# Simulate the connection from the gateway node to the backend as a single link
# to the satellite. Assume once data has gotten to the satellite, everything
# else is instant.
[links.gateway_to_backend]
# Assume ideal links after satellite receives packet.
next = "ideal"            
# Iridium 9603 transmission rate (176 kbps).
trans_rate = 176000       
# Simulate a one-time delay of 20s when connecting.
connection_delay.avg = 20       
# Simulated delay for all processing in satellite.
processing_delay.avg = 60       
# 30% chance packet fails to send.
packet_loss = 0.3         

[links.lora]
# Lora is a radio protocol - no routing.
next = "none"             
# Small chance of losing a packet.
packet_loss = 0.01        
# lora is about 1kbps transmission rate.
trans_rate = 1000         

# Assume about 0.5s propagation delay.
propagation_delay.avg = 0.5      
# Assume about 0.1s standard deviation in delay.
propagation_delay.std = 0.1      
# Assume distance independence (not realistic).
propagation_delay.modifier = "flat"   

[links.lora_bad]
inherit = "lora"
next = "none"             
packet_loss = 0.05        
trans_rate = 1000

propagation_delay.avg = 1
propagation_delay.std = 0.25      
propagation_delay.modifier = "flat"   

[nodes]

# The default node which all other nodes inherit from
[nodes.default]

# Array of [X, Y] coordinates for all the locations which this class of node is
# deployed. At build time, each instance of the node protocols will be assigned
# its index as a unique id which will be used to uniquely identify its output
# in the simulation folder.
positions = []

# Array of internal link names which act like ideal links but cannot be
# received from any node outside of this one. Overrides existing link names,
# and is subject to the same naming restrictions as links.
internal_names = []

[nodes.gateway]

internal_names = ["satellite"]
positions = [[0, 0]]

# TODO: Add power to simulation
# default_charge = 1.0    # Start fully charged
# idle_power = 0.001      # Percentage of charge used per second
# idle_charging = 0.005   # Percentage of charge recovered per second
# ...other charging params

# The gateway node's satellite communication protocol which accepts packets
# from the tdma protocol and then transmits them via satellite.
[[nodes.gateway.protocols]]
# Name for the protocol to use as a unique identifier
name = "satcom"
# File system root directory for this protocol.
root = "~/nodes/gateway/satcom" 
# Shell command to run from root at startup.
runner = "make"                 
runner_args = []

# Array of real or internal links this node can accept.
accepts = ["satellite"]  # Only accept data sent over the satellite link name.

# Array signalling all the outgoing direct link connections.
# [<node>, <link>]
#   - `node`: The name of the node for the direct connection.
#   - `link`: The name of the link to use.
direct = [ 
    ["backend", "gateway_to_backend"],  # Simulate satellite uplink
]

# This node performs the tdma protocol of the gateway, including:
#   - Pushing the time to all leaf nodes
#   - Listening during the tdma window for node packets
#       - Buffering node packets
#       - Writing packets to the satellite
[[nodes.gateway.protocols]]
name = "tdma"
root = "~/nodes/gateway/tdma"
runner = "make"
runner_args = []
accepts = ["lora"]
direct = [
    ["self", "satellite"],
]

# Array of tuples with the structure:
# [<max_range>, .modifierifier_offset>, <link>]
#   - `max_range`: The maximum range (in meters) a link will transmit data.
#   - .modifierifier_offset`: An offset used when computing non-flat modifier values
#       for packet loss or delays. Must be <= `max_range` and >= 0. 
#       Actual.modifierifier used is equal to: `max_range` - `modifier_offset`.
#   - `link`: The name of the link to use.
indirect = [
    # 4km range maximum transmission range.
    # Modifier computations use a distance.modifierifier of 0 until the 2km mark.
    # Link is done over lora.
    [4000, 2000, "lora"]
]

[nodes.peripheral]

positions = [
    [0, 1000],
    [1000, 0],
    [0, -1000],
    [-1000, 0],
]

[[nodes.peripheral.protocols]]
name = "tdma"
root = "~/nodes/peripheral/tdma"
runner = "make"
runner_args = []
accepts = ["lora"]
indirect = [
    [4000, 2000, "lora"]
]

# The "backend" node is used to simulate the packaging of packets by the
# Cloudloop server and storing the data in a Flask web server.
[nodes.backend]

# Backend node that receives the raw satellite packets and packages them up
# like how Cloudloop does to then send to the flask app over HTTP request.
[[nodes.backend.protocols]]
name = "package"
root = "~/nodes/backend/flaskapp"
runner = "make"
runner_args = []
accepts = ["gateway_to_backend"]

# Flask app which gets started and then idly accepts HTTP requests from the
# other node protocol that accepts raw packets and packages them up like
# Cloudloop does. Stores sensor packets locally.
[[nodes.backend.protocols]]
name = "flaskapp"
root = "~/nodes/backend/flaskapp"
runner = "make"
runner_args = []
accepts = []
direct = []
indirect = []
